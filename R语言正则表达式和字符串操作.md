# 正则表达式和字符串操作
First in first，看R系统中的正则表达式的帮助文档！
```
?regex
```
用help( package ="stringr")正则表达式部分，有非常好的链接！！！
http://regexr.com ; 其中老版本v1的sample例子可以学习一下。
http://www.regular-expressions.info/refquick.html

## R的正则表达式中预定义的字符串选集

预定义<br/>字符串|解释说明
--|--
[:digit:]|0-9数字
[:lower:]|当前语言环境的小写字母
[:upper:]|当前语言环境的大写字母
[:alpha:]|字母字符a-zA-Z，包括[:lower:]和[:upper:]
[:alnum:]|数字和字母字符[:alpha:]和[:digit:]
[:punct:]|标点符号：.,;是否包括中文标点符号？依赖于语言环境
[:graph:]|图形字符，包括[:alnum:]和[:punct:]
[:blank:]|空格字符：空格和制表
[:space:]|空字符，包括空格、制表、换行和其他空字符！！！
[:print:]|可打印显示字符：[:alnum:]，[:punct:]和[:space:]

在正则表达式中预定义字符串必须放在`[]`之中。例如，"[[:digit:]abc]"表示可以为数字和字母abc。

插入符(caret)` ^` 和美元符号` $`都是分别匹配一行的开头和结尾的空字符串的元字符。符号\ b匹配单词的边界； \ B匹配不在一个单词的边缘。

元字符，在正则表达式中有特殊含义的字符。
常见的有：`. \ | ( ) [ ]{} ^ $ * + ?-`
要在正则表示式中使用这些字符的原意而不是特殊含义时，前面要加`\\`,；例如，`\\.`，而在stringr包中的函数的正则式中可以直接用fix()将其包裹。类似地，在stringr包中可以将字符串用ignore.case()包裹，来使得匹配时不计大小写。

广义化符号|解释说明
--|--
不在`[]`中的`.`|匹配任意字符。
转义符`\` | 常见的转义\n,\r和\t等
`[]`包裹的字符类(character class)|意味着与[]中的字符之一匹配即可。被包裹在之中在`[]`中英文句号.不表示任意字符。
范围操作符`-`|表示连续的编码范围
[^字符集]|排除字符集，与非字符集的字符匹配
`()`组块符|将一组字符组成块或捕获组
注意：R的正则式中*不表示任意字符，而是表示匹配0次以上。
大多数元字符在`[]`中会失去特殊含义，但减号`-`只要不在首尾还是做范围符。


## R的正则表达式中特殊含义的符号
一个规则特殊含义字符中大写字母的含义正好是小写字母的反义！

特殊含义符号|解释说明
--|--
\w|单词字符()，相当于[[:alnum:]_]
\W|非字母数字串，相当于[^[:alnum:]_]
\s|空字符[[:blank:]]
\S|非空字符[^[:blank:]]
\d|数字[[:digit:]]
\D|非数字[^[:digit:]]
\b|单词的边界
\B|非单词的边界

例如：\bE(\w*)t\b表示单词以E开始t结尾


## R的正则表达式中量化符
正则表达式之后可以是几个重复量词之一:

特殊含义符号|解释说明
--|--
?|前面的元素是可选的，且最多匹配一次{0,1}
*|前面的元素会被匹配0次以上
+|前面的元素会被匹配1次以上
+?|非贪婪匹配
{n}|前面的元素会被匹配n次
{n,}|前面的元素会被匹配n次以上
{n,m}|前面的元素会被匹配n次以上但不超过m次

?: 非捕获组. 将多个字符组合在一起，而不创建捕获组.

##回向引用，反向引用（backreferencing）

在正则表达式前部依次用()界定捕获组块1、块2，然后在后面引用\\1,\\2。例如，"(块1)(块2)中间省略\\1中间省略\\2"
正则表达式最多有9个回向引用，分别标为\\1,\\2...
```
#字母字符直到该字符之间所有字符串
str_extract(example,"([[:alpha:]]).+?\\1")

```
## stringr包的字符操作函数

该包中函数的一般形式为：字符串操作函数名（字符串向量，模式）；在该包中，关于字符串的操作一般都有`str_操作()`和`str_操作_all()`两个函数。 前者对匹配模式的第一个块进行操作，后者对匹配模式的所有块进行操作。因为对于字符串向量中每个字符串匹配模式的所有块的个数不是固定的，所以，`str_操作_all()`函数返回的是与输入的字符串向量长度相等的列表。在该列表中的每个元素是与输入字符串向量中对应位置的字符串的操作结果。


### 使用正则表达式的函数
函数名称|解释说明|返回值
--|--|--
str_extract()|提取匹配特征的第一个字符串|字符向量
str_extract_all()|提取匹配特征的所有字符串|字符向量的列表
str_locate()|返回匹配特征的第一个位置|起始/结尾位置的矩阵
str_locate_all()|返回匹配特征的所有位置|矩阵的列表
str_replace()|替换第一个特征的匹配|字符向量
str_replace_all()|替换所有的特征的匹配|字符向量的列表
str_split()|在特征匹配的位置拆分字符串|字符向量的列表
str_split_fixed()|在特征匹配的位置拆分为固定块数的字符串|字符向量的矩阵
str_detect()|在字符串中检测特征是否存在|逻辑向量
str_count()|在字符串中检测特征出现的次数|数字向量
str_subset()|在字符串筛选模式匹配的字符串|字符向量

### 不使用正则表达式的函数

函数名称|解释说明|返回值
--|--|--
str_sub()|根据位置提取字符串|字符向量
str_dup()|复制字符串|字符向量
str_length()|返回字符串长度|数字向量
str_pad()|给字符串留空|字符向量
str_trim()|去除字符串两端的空白|字符向量
str_c()|拼接多个字符串|字符向量

str_trim()去除的空白包括空格、制表位、回车等

stringr不是通过参数来对匹配进行控制，但是通过修饰符函数来控制`regexp()`, `coll()`, `ignore.case()`以及`fixed()`. 这是为了简化这些函数而刻意作出的一个选择。例如，当`grepl()`有六个参数时，`str_detect()`只有两个。


> Written with [StackEdit](https://stackedit.io/).